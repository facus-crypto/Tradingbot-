import logging
import requests
import json
import time

class TelegramAdvancedBot:
    def __init__(self, token: str, chat_id: str):
        self.token = token
        self.chat_id = chat_id
        self.base_url = f"https://api.telegram.org/bot{token}"
        logging.info(f"Bot Telegram inicializado para chat: {chat_id}")
    
    async def start(self):
    def send_message(self, text):
        """MÃ©todo dummy para compatibilidad"""
        pass
        """MÃ©todo dummy para compatibilidad con sistema principal"""
        pass
    def send_signal(self, signal_id, symbol, side, entry, sl, tp, comment, trailing_info=None):
        """
        EnvÃ­a seÃ±al con botones REALES - Formato SUPER SIMPLE
        """
        try:
            # LISTA VERTICAL de mercados
            monitored_symbols = ["BTC", "ETH", "SOL", "LINK", "BNB", "ADA", "AVAX", "XRP", "DOT", "ATOM"]
            symbols_list = "\n".join([f"â€¢ {s}" for s in monitored_symbols])
            
            # Preparar datos de trailing
            if trailing_info:
                phase = trailing_info.get('phase', 1)
                dynamic_sl = trailing_info.get('dynamic_sl', sl)
                dynamic_tp = trailing_info.get('dynamic_tp', tp)
                pnl = trailing_info.get('pnl_percent', 0.0)
            else:
                phase = 1
                dynamic_sl = sl
                dynamic_tp = tp
                pnl = 0.0
            
            # Mensaje SIMPLE sin f-strings complejos
            message = f"""ğŸŸ¡ SEÃ‘AL DETECTADA ğŸŸ¡

ğŸ“Š Par: {symbol}
ğŸ“ˆ DirecciÃ³n: {side}
ğŸ’° Precio Entrada: ${entry:,.2f}
ğŸ›‘ Stop Loss: ${sl:,.2f}
ğŸ¯ Take Profit: ${tp:,.2f}

ğŸ“Š Trailing Stop:
â€¢ Fase: {phase}
â€¢ SL DinÃ¡mico: ${dynamic_sl:,.2f}
â€¢ TP DinÃ¡mico: ${dynamic_tp:,.2f}
â€¢ PnL Actual: {pnl:.2f}%

ğŸ“ Nota: {comment}

ğŸ“‹ Mercados Monitoreados:
{symbols_list}

â° VÃ¡lido por: 3 minutos"""
            
            # Enviar con botones REALES
            response = requests.post(
                f"{self.base_url}/sendMessage",
                json={
                    'chat_id': self.chat_id,
                    'text': message,
                    'parse_mode': 'HTML',
                    'reply_markup': {
                        'inline_keyboard': [[
                            {'text': 'âœ… EJECUTAR', 'callback_data': f'execute_{signal_id}'},
                            {'text': 'âŒ CANCELAR', 'callback_data': f'cancel_{signal_id}'}
                        ]]
                    }
                }
            ).json()
            
            if response.get('ok'):
                logging.info(f"âœ… SeÃ±al {signal_id} enviada: {symbol} {side}")
                return True
            else:
                logging.error(f"âŒ Error enviando seÃ±al: {response}")
                return False
                
        except Exception as e:
            logging.error(f"âŒ Error en send_signal: {e}")
            return False

# FunciÃ³n simple para importar
def send_signal(signal_id, symbol, side, entry, sl, tp, comment, trailing_info=None):
    """FunciÃ³n simple para enviar seÃ±ales"""
    try:
        # Cargar configuraciÃ³n
        with open('config_futures.json', 'r') as f:
            config = json.load(f)
        
        token = config['telegram']['bot_token']
        chat_id = config['telegram']['chat_id']
        
        # Crear bot y enviar seÃ±al
        bot = TelegramAdvancedBot(token, chat_id)
        return bot.send_signal(signal_id, symbol, side, entry, sl, tp, comment, trailing_info)
    except Exception as e:
        logging.error(f"Error: {e}")
        return False

    async def start(self):
    def send_message(self, text):
        """MÃ©todo dummy para compatibilidad"""
        pass
        """MÃ©todo dummy para compatibilidad con sistema principal"""
        pass
