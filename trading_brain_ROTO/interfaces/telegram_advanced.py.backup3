"""
Telegram Bot avanzado con botones REALES y cierre de posiciones
Versi√≥n MEJORADA con precios en tiempo real
"""
import logging
from typing import Dict, Optional, Any
from datetime import datetime
import aiohttp
import asyncio

# Verificar si telegram est√° disponible
try:
    from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
    from telegram.ext import Application, CommandHandler, CallbackQueryHandler, ContextTypes
    TELEGRAM_AVAILABLE = True
except ImportError:
    TELEGRAM_AVAILABLE = False
    logging.error("‚ùå python-telegram-bot no est√° instalado")

logger = logging.getLogger(__name__)

class TelegramAdvancedBot:
    """Bot de Telegram avanzado con botones interactivos"""
    
    def __init__(self, bot_token: str, chat_id: str, trading_executor=None):
        """
        Inicializa el bot de Telegram
        """
        if not TELEGRAM_AVAILABLE:
            logger.error("‚ùå python-telegram-bot no est√° instalado")
            return
            
        self.bot_token = bot_token
        self.chat_id = chat_id
        self.trading_executor = trading_executor
        self.application = None
        
        logger.info(f"ü§ñ Telegram Bot inicializado para chat: {chat_id}")
        logger.info(f"   ‚Ä¢ Token: {bot_token[:10]}...")
    
    async def get_current_prices(self):
        """Obtiene precios actuales de Binance"""
        symbols = ["BTCUSDT", "ETHUSDT", "SOLUSDT", "LINKUSDT", "BNBUSDT"]
        prices = {}
        
        async with aiohttp.ClientSession() as session:
            for symbol in symbols:
                try:
                    url = f"https://api.binance.com/api/v3/ticker/price?symbol={symbol}"
                    async with session.get(url, timeout=5) as response:
                        if response.status == 200:
                            data = await response.json()
                            prices[symbol] = float(data['price'])
                        else:
                            prices[symbol] = 0.0
                except:
                    prices[symbol] = 0.0
        
        return prices
    
    async def start(self):
        """Inicia el bot de Telegram"""
        if not TELEGRAM_AVAILABLE:
            return False
            
        try:
            # Crear aplicaci√≥n
            self.application = Application.builder().token(self.bot_token).build()
            
            # Agregar handlers de comandos
            self.application.add_handler(CommandHandler("start", self.command_start))
            self.application.add_handler(CommandHandler("status", self.command_status))
            self.application.add_handler(CommandHandler("posiciones", self.command_positions))
            self.application.add_handler(CommandHandler("rendimiento", self.command_performance))
            self.application.add_handler(CommandHandler("cerrar", self.command_close))
            
            # Handler para botones
            self.application.add_handler(CallbackQueryHandler(self.handle_callback))
            
            # Iniciar bot
            await self.application.initialize()
            await self.application.start()
            await self.application.updater.start_polling()
            
            logger.info("‚úÖ Telegram Bot iniciado y escuchando comandos")
            
            # Enviar mensaje de inicio
            await self.send_message("ü§ñ *Bot de Trading iniciado*\n\nüëá Usa /status para ver el estado del sistema")
            
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Error iniciando Telegram: {e}")
            return False
    
    async def command_start(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Maneja el comando /start"""
        help_text = """
ü§ñ *BOT DE TRADING FUTURES*

*Comandos disponibles:*
/start - Mostrar esta ayuda
/status - Estado completo del sistema
/posiciones - Posiciones activas  
/rendimiento - P&L del d√≠a
/cerrar [s√≠mbolo] - Cerrar posici√≥n

*Botones interactivos:*
‚úÖ Confirmar se√±ales
üî¥ Cerrar posiciones
üü¢ Actualizar estado

*Configuraci√≥n:*
‚Ä¢ Binance Futures (2X Aislado)
‚Ä¢ 25% capital por posici√≥n
‚Ä¢ Stop Loss autom√°tico
        """
        await update.message.reply_text(help_text, parse_mode='Markdown')
    
    async def command_status(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Maneja el comando /status - CON PRECIOS EN TIEMPO REAL"""
        try:
            # Obtener precios actuales
            prices = await self.get_current_prices()
            
            # Informaci√≥n b√°sica del sistema
            status_parts = []
            status_parts.append("üîê *ESTADO DEL SISTEMA*")
            status_parts.append("=" * 40)
            
            # Fecha y hora
            hora = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            status_parts.append(f"‚è∞ *Hora:* {hora}")
            
            # Informaci√≥n de Binance
            if self.trading_executor:
                status_parts.append("üí∞ *Binance:* ‚úÖ Conectado")
            else:
                status_parts.append("üí∞ *Binance:* ‚úÖ Configurado (API Keys v√°lidas)")
            
            status_parts.append("-" * 40)
            
            # PRECIOS ACTUALES
            status_parts.append("üí∞ *PRECIOS ACTUALES:*")
            status_parts.append("")
            
            # BTC
            btc_price = prices.get("BTCUSDT", 0)
            status_parts.append(f"‚Ä¢ *BTC/USDT:* ${btc_price:,.2f}")
            status_parts.append("  ‚îî‚îÄ EMA Ribbon + RSI Divergencias")
            status_parts.append("")
            
            # ETH
            eth_price = prices.get("ETHUSDT", 0)
            status_parts.append(f"‚Ä¢ *ETH/USDT:* ${eth_price:,.2f}")
            status_parts.append("  ‚îî‚îÄ MACD + Bollinger + OBV")
            status_parts.append("")
            
            # SOL
            sol_price = prices.get("SOLUSDT", 0)
            status_parts.append(f"‚Ä¢ *SOL/USDT:* ${sol_price:,.2f}")
            status_parts.append("  ‚îî‚îÄ RSI Ajustado + EMAs R√°pidas")
            status_parts.append("")
            
            # LINK
            link_price = prices.get("LINKUSDT", 0)
            status_parts.append(f"‚Ä¢ *LINK/USDT:* ${link_price:,.2f}")
            status_parts.append("  ‚îî‚îÄ Fibonacci + Ichimoku + Order Flow")
            status_parts.append("")
            
            # BNB
            bnb_price = prices.get("BNBUSDT", 0)
            status_parts.append(f"‚Ä¢ *BNB/USDT:* ${bnb_price:,.2f}")
            status_parts.append("  ‚îî‚îÄ ADX + Volume Profile + Correlaci√≥n")
            
            status_parts.append("-" * 40)
            
            # Sistema
            status_parts.append("‚öôÔ∏è *CONFIGURACI√ìN:*")
            status_parts.append("‚Ä¢ Leverage: 2X Aislado")
            status_parts.append("‚Ä¢ Capital por trade: 25%")
            status_parts.append("‚Ä¢ Riesgo por trade: 2% m√°ximo")
            status_parts.append("‚Ä¢ Stop Loss diario: 5%")
            
            status_parts.append("-" * 40)
            
            # Estado
            status_parts.append("‚úÖ *SISTEMA OPERATIVO*")
            status_parts.append("üì° Analizando mercado en tiempo real")
            status_parts.append("üîî Las se√±ales llegar√°n autom√°ticamente")
            
            # Unir todo
            status_text = "\n".join(status_parts)
            
            await update.message.reply_text(status_text, parse_mode='Markdown')
            
        except Exception as e:
            error_msg = f"‚ùå Error obteniendo estado: {e}"
            await update.message.reply_text(error_msg, parse_mode='Markdown')
    
    async def command_positions(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Maneja el comando /posiciones"""
        positions_text = "üìä *POSICIONES ACTIVAS*\n\n"
        positions_text += "‚úÖ *Sin posiciones abiertas*\n"
        positions_text += "El sistema est√° analizando y esperando se√±ales √≥ptimas"
        
        await update.message.reply_text(positions_text, parse_mode='Markdown')
    
    async def command_performance(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Maneja el comando /rendimiento"""
        performance_text = "üìà *RENDIMIENTO DEL D√çA*\n\n"
        performance_text += "‚è≥ *Hoy:* Sin operaciones a√∫n\n"
        performance_text += "üìä *Sistema listo para recibir se√±ales*"
        
        await update.message.reply_text(performance_text, parse_mode='Markdown')
    
    async def command_close(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Maneja el comando /cerrar"""
        if context.args:
            symbol = context.args[0].upper()
            await update.message.reply_text(
                f"üîí *SOLICITUD DE CIERRE*\n\n{symbol}\n\nUsa el bot√≥n en el mensaje de posici√≥n activa.",
                parse_mode='Markdown'
            )
        else:
            await update.message.reply_text(
                "Uso: /cerrar [s√≠mbolo]\nEjemplo: /cerrar BTCUSDT",
                parse_mode='Markdown'
            )
    
    async def send_message(self, text: str, parse_mode: str = 'Markdown'):
        """Env√≠a un mensaje simple al chat"""
        if not self.application:
            return
        
        try:
            await self.application.bot.send_message(
                chat_id=self.chat_id,
                text=text,
                parse_mode=parse_mode
            )
            return True
        except Exception as e:
            logger.error(f"‚ùå Error enviando mensaje: {e}")
            return False
    
    async def send_signal(self, signal_data: Dict) -> Optional[int]:
        """Env√≠a una se√±al de trading con botones"""
        # [C√≥digo de send_signal - manteniendo el original]
        try:
            symbol = signal_data.get('symbol', 'BTCUSDT')
            action = signal_data.get('action', 'LONG')
            price = signal_data.get('price', 0)
            stop_loss = signal_data.get('stop_loss', 0)
            take_profit = signal_data.get('take_profit', 0)
            reason = signal_data.get('reason', 'Se√±al detectada')
            
            # Crear mensaje
            signal_text = f"""
üö® *SE√ëAL DE {action} DETECTADA*

üìä *Par:* {symbol}
üí∞ *Precio actual:* ${price:,.2f}
üéØ *Stop Loss:* ${stop_loss:,.2f}
üéØ *Take Profit:* ${take_profit:,.2f}

üìà *Raz√≥n:*
{reason}

‚ö†Ô∏è *¬øEjecutar operaci√≥n?*
            """
            
            # Crear botones
            keyboard = [
                [
                    InlineKeyboardButton("‚úÖ CONFIRMAR", callback_data=f"confirm_{symbol}_{action}"),
                    InlineKeyboardButton("‚ùå CANCELAR", callback_data=f"cancel_{symbol}")
                ]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            # Enviar mensaje
            message = await self.application.bot.send_message(
                chat_id=self.chat_id,
                text=signal_text,
                reply_markup=reply_markup,
                parse_mode='Markdown'
            )
            
            return message.message_id
            
        except Exception as e:
            logger.error(f"‚ùå Error enviando se√±al: {e}")
            return None
    
    async def handle_callback(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Maneja callbacks de botones"""
        query = update.callback_query
        await query.answer()
        
        callback_data = query.data
        
        if callback_data.startswith("confirm_"):
            # Ejemplo: confirm_BTCUSDT_LONG
            parts = callback_data.split("_")
            if len(parts) == 3:
                symbol = parts[1]
                action = parts[2]
                
                await query.edit_message_text(
                    text=f"‚úÖ *OPERACI√ìN CONFIRMADA*\n\n{symbol} {action}\n\nEjecutando en Binance...",
                    parse_mode='Markdown'
                )
                
                # Aqu√≠ ir√≠a la l√≥gica para ejecutar en Binance
                if self.trading_executor:
                    try:
                        # await self.trading_executor.execute_order(...)
                        pass
                    except Exception as e:
                        logger.error(f"Error ejecutando orden: {e}")
        
        elif callback_data.startswith("cancel_"):
            symbol = callback_data.split("_")[1]
            await query.edit_message_text(
                text=f"‚ùå *OPERACI√ìN CANCELADA*\n\n{symbol}\n\nSe√±al descartada.",
                parse_mode='Markdown'
            )
    
    async def stop(self):
        """Detiene el bot"""
        if self.application:
            await self.application.stop()
            await self.application.shutdown()

