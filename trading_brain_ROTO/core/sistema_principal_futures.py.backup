"""
SISTEMA PRINCIPAL ACTUALIZADO PARA BINANCE FUTURES
Integra 5 cerebros especializados + Telegram avanzado + Ejecuci√≥n real
"""
import logging
import asyncio
import sys
import os
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any
import json

# Configurar logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('trading_system.log'),
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger(__name__)

# A√±adir directorio actual al path
sys.path.append('.')

# Importar cerebros actualizados
try:
    from cerebros.cerebro_base_futures import CerebroFuturesBase
    from cerebros.cerebro_btc_futures import CerebroBTC
    from cerebros.cerebro_eth_futures import CerebroETH
    from cerebros.cerebro_sol_futures import CerebroSOL
    from cerebros.cerebro_link_futures import CerebroLINK
    from cerebros.cerebro_bnb_futures import CerebroBNB
    
    CEREBROS_IMPORTADOS = True
    logger.info("‚úÖ Todos los cerebros Futures importados correctamente")
except ImportError as e:
    CEREBROS_IMPORTADOS = False
    logger.error(f"‚ùå Error importando cerebros: {e}")

# Importar gestor Binance (ya existente)
try:
    from binance_manager_custom import get_binance_manager
    BINANCE_IMPORTADO = True
except ImportError:
    BINANCE_IMPORTADO = False
    logger.warning("‚ö†Ô∏è  BinanceFuturesManager no encontrado, usando simulaci√≥n")

# Importar Telegram avanzado (ya existente)
try:
    from interfaces.telegram_advanced import TelegramAdvancedBot
    TELEGRAM_IMPORTADO = True
except ImportError:
    TELEGRAM_IMPORTADO = False
    logger.warning("‚ö†Ô∏è  TelegramAdvancedBot no encontrado")

class SistemaPrincipalFutures:
    """
    Sistema principal que coordina 5 cerebros de trading con Binance Futures
    """
    
    def __init__(self, config_path: str = "config_futures.json"):
        """
        Inicializa el sistema completo
        
        Args:
            config_path: Ruta al archivo de configuraci√≥n
        """
        self.config = self.cargar_configuracion(config_path)
        self.estado = "INICIALIZANDO"
        self.iniciado_en = datetime.now()
        
        # Instancias principales
        self.binance_manager = None
        self.telegram_bot = None
        self.cerebros = {}
        
        # Control de ciclo
        self.ciclo_activo = False
        self.intervalo_analisis = 60  # segundos entre an√°lisis
        self.max_ciclos = None  # None para infinito
        
        # Estad√≠sticas
        self.estadisticas = {
            'ciclos_completados': 0,
            'se√±ales_generadas': 0,
            'se√±ales_enviadas_telegram': 0,
            'errores': 0,
            'ultimo_ciclo': None,
            'posiciones_activas': 0
        }
        
        # Cache de datos
        self.datos_cache = {}
        self.cache_validez = 300  # segundos
        
        logger.info("üöÄ Sistema Principal Futures inicializado")
    
    def cargar_configuracion(self, config_path: str) -> Dict:
        """Carga la configuraci√≥n desde archivo JSON"""
        config_default = {
            "binance": {
                "api_key": "",
                "api_secret": "",
                "testnet": False,
                "leverage": 2,
                "margin_type": "ISOLATED",
                "position_percent": 0.25,
                "risk_per_trade": 0.02
            },
            "telegram": {
                "token": "",
                "chat_id": "",
                "notificar_se√±ales": True,
                "notificar_errores": True,
                "notificar_cierre": True
            },
            "cerebros": {
                "BTCUSDT": {"activo": True, "estrategia": "ema_ribbon_rsi"},
                "ETHUSDT": {"activo": True, "estrategia": "macd_bollinger"},
                "SOLUSDT": {"activo": True, "estrategia": "rsi_ajustado"},
                "LINKUSDT": {"activo": True, "estrategia": "fibonacci_ichimoku"},
                "BNBUSDT": {"activo": True, "estrategia": "adx_volume_profile"}
            },
            "sistema": {
                "intervalo_analisis": 60,
                "max_posiciones_simultaneas": 3,
                "stop_loss_diario": 0.05,
                "modo_prueba": False,
                "log_level": "INFO"
            }
        }
        
        try:
            if os.path.exists(config_path):
                with open(config_path, 'r') as f:
                    config = json.load(f)
                logger.info(f"‚úÖ Configuraci√≥n cargada desde {config_path}")
                
                # Combinar con defaults para valores faltantes
                for key, value in config_default.items():
                    if key not in config:
                        config[key] = value
                    elif isinstance(value, dict):
                        for subkey, subvalue in value.items():
                            if subkey not in config[key]:
                                config[key][subkey] = subvalue
                
                return config
            else:
                logger.warning(f"‚ö†Ô∏è  Archivo de configuraci√≥n {config_path} no encontrado, usando defaults")
                return config_default
                
        except Exception as e:
            logger.error(f"‚ùå Error cargando configuraci√≥n: {e}")
            return config_default
    
    async def inicializar_binance(self) -> bool:
        """Inicializa conexi√≥n con Binance Futures"""
        if not BINANCE_IMPORTADO:
            logger.warning("‚ö†Ô∏è  BinanceFuturesManager no disponible, usando modo simulaci√≥n")
            self.binance_manager = self.SimuladorBinance()
            return True
        
        try:
            api_key = self.config['binance']['api_key']
            api_secret = self.config['binance']['api_secret']
            
            if not api_key or not api_secret:
                logger.warning("‚ö†Ô∏è  API keys de Binance no configuradas, usando simulaci√≥n")
                self.binance_manager = self.SimuladorBinance()
                return True
            
            self.binance_manager = get_binance_manager(
                api_key=api_key,
                api_secret=api_secret,
                testnet=self.config['binance']['testnet']
            )
            
            # Configurar leverage y margen
            await self.binance_manager.set_leverage(
                leverage=self.config['binance']['leverage']
            )
            await self.binance_manager.set_margin_type(
                margin_type=self.config['binance']['margin_type']
            )
            
            # Obtener balance
            balance = await self.binance_manager.get_balance()
            logger.info(f"üí∞ Balance Binance: {balance:.2f} USDT")
            
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Error inicializando Binance: {e}")
            self.binance_manager = self.SimuladorBinance()
            return False
    
    async def inicializar_telegram(self) -> bool:
        """Inicializa bot de Telegram avanzado"""
        if not TELEGRAM_IMPORTADO:
            logger.warning("‚ö†Ô∏è  TelegramAdvancedBot no disponible")
            return False
        
        try:
            token = self.config['telegram']['token']
            chat_id = self.config['telegram']['chat_id']
            
            if not token:
                logger.warning("‚ö†Ô∏è  Token de Telegram no configurado")
                return False
            
            self.telegram_bot = TelegramAdvancedBot(
                bot_token=token,
                chat_id=chat_id,
                binance_manager=self.binance_manager
            )
            
            await self.telegram_bot.start()
            logger.info("‚úÖ Bot de Telegram inicializado")
            
            # Enviar mensaje de inicio
            mensaje_inicio = (
                "üöÄ *SISTEMA DE TRADING FUTURES INICIADO*\n"
                f"‚Ä¢ Hora: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"
                f"‚Ä¢ Cerebros activos: {len([c for c in self.config['cerebros'].values() if c['activo']])}/5\n"
                f"‚Ä¢ Intervalo an√°lisis: {self.config['sistema']['intervalo_analisis']}s\n"
                f"‚Ä¢ Modo: {'PRUEBA' if self.config['sistema']['modo_prueba'] else 'REAL'}"
            )
            
            await self.telegram_bot.send_message(mensaje_inicio)
            
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Error inicializando Telegram: {e}")
            return False
    
    async def inicializar_cerebros(self) -> bool:
        """Inicializa todos los cerebros de trading"""
        if not CEREBROS_IMPORTADOS:
            logger.error("‚ùå No se pudieron importar los cerebros")
            return False
        
        try:
            cerebros_config = self.config['cerebros']
            cerebro_btc = None
            
            # 1. Inicializar BTC primero (para correlaci√≥n con BNB)
            if cerebros_config['BTCUSDT']['activo']:
                cerebro_btc = CerebroBTC(
                    binance_manager=self.binance_manager,
                    telegram_bot=self.telegram_bot
                )
                self.cerebros['BTCUSDT'] = cerebro_btc
                logger.info(f"‚úÖ Cerebro BTC inicializado - {cerebro_btc.estrategia}")
            
            # 2. Inicializar los dem√°s cerebros
            cerebros_a_inicializar = [
                ('ETHUSDT', CerebroETH),
                ('SOLUSDT', CerebroSOL),
                ('LINKUSDT', CerebroLINK)
            ]
            
            for simbolo, clase_cerebro in cerebros_a_inicializar:
                if cerebros_config[simbolo]['activo']:
                    cerebro = clase_cerebro(binance_manager=self.binance_manager, 
                        telegram_bot=self.telegram_bot
                    )
                    self.cerebros[simbolo] = cerebro
                    logger.info(f"‚úÖ Cerebro {simbolo} inicializado - {cerebro.estrategia}")
            
            # 3. Inicializar BNB con referencia a BTC (para correlaci√≥n)
            if cerebros_config['BNBUSDT']['activo']:
                cerebro_bnb = CerebroBNB(
                    binance_manager=self.binance_manager,
                    telegram_bot=self.telegram_bot,
                    btc_cerebro=cerebro_btc
                )
                self.cerebros['BNBUSDT'] = cerebro_bnb
                logger.info(f"‚úÖ Cerebro BNB inicializado - {cerebro_bnb.estrategia}")
            
            logger.info(f"üéØ Total cerebros inicializados: {len(self.cerebros)}/5")
            return len(self.cerebros) > 0
            
        except Exception as e:
            logger.error(f"‚ùå Error inicializando cerebros: {e}")
            return False
    
    async def ciclo_analisis(self) -> Dict:
        """
        Ejecuta un ciclo completo de an√°lisis con todos los cerebros
        
        Returns:
            Dict con resultados del ciclo
        """
        resultados = {
            'timestamp': datetime.now().isoformat(),
            'cerebros_analizados': 0,
            'se√±ales_generadas': 0,
            'se√±ales_procesadas': 0,
            'errores': 0,
            'detalles': {}
        }
        
        logger.info(f"üîÑ Iniciando ciclo de an√°lisis #{self.estadisticas['ciclos_completados'] + 1}")
        
        # Ejecutar an√°lisis en paralelo para cada cerebro
        tareas = []
        for simbolo, cerebro in self.cerebros.items():
            tareas.append(self.analizar_cerebro(simbolo, cerebro))
        
        # Esperar a que todos los cerebros terminen
        if tareas:
            resultados_cerebros = await asyncio.gather(*tareas, return_exceptions=True)
            
            for i, (simbolo, cerebro) in enumerate(self.cerebros.items()):
                if i < len(resultados_cerebros):
                    resultado = resultados_cerebros[i]
                    
                    if isinstance(resultado, Exception):
                        resultados['errores'] += 1
                        resultados['detalles'][simbolo] = {
                            'estado': 'ERROR',
                            'error': str(resultado)
                        }
                        logger.error(f"‚ùå Error en cerebro {simbolo}: {resultado}")
                    else:
                        resultados['cerebros_analizados'] += 1
                        resultados['detalles'][simbolo] = resultado
                        
                        if resultado['senal_generada']:
                            resultados['se√±ales_generadas'] += 1
                        
                        if resultado['senal_procesada']:
                            resultados['se√±ales_procesadas'] += 1
        
        # Actualizar estad√≠sticas
        self.estadisticas['ciclos_completados'] += 1
        self.estadisticas['se√±ales_generadas'] += resultados['se√±ales_generadas']
        self.estadisticas['errores'] += resultados['errores']
        self.estadisticas['ultimo_ciclo'] = resultados['timestamp']
        
        logger.info(f"‚úÖ Ciclo completado: "
                   f"{resultados['cerebros_analizados']} cerebros, "
                   f"{resultados['se√±ales_generadas']} se√±ales, "
                   f"{resultados['errores']} errores")
        
        return resultados
    
    async def analizar_cerebro(self, simbolo: str, cerebro: CerebroFuturesBase) -> Dict:
        """
        Ejecuta an√°lisis para un cerebro espec√≠fico
        
        Args:
            simbolo: S√≠mbolo del par
            cerebro: Instancia del cerebro
            
        Returns:
            Dict con resultados del an√°lisis
        """
        resultado = {
            'simbolo': simbolo,
            'estado': 'INICIADO',
            'senal_generada': False,
            'senal_procesada': False,
            'timestamp': datetime.now().isoformat(),
            'error': None
        }
        
        try:
            # 1. Ejecutar an√°lisis
            senal = await cerebro.analizar()
            
            if senal:
                resultado['senal_generada'] = True
                resultado['senal'] = senal
                resultado['estado'] = 'SE√ëAL_GENERADA'
                
                logger.info(f"üì° {simbolo} - Se√±al {senal['action']} "
                           f"(conf: {senal['confidence']:.0%})")
                
                # 2. Procesar se√±al (enviar a Telegram)
                if self.telegram_bot and self.config['telegram']['notificar_se√±ales']:
                    procesamiento = await cerebro.procesar_senal(senal)
                    
                    if procesamiento['status'] == 'sent_to_telegram':
                        resultado['senal_procesada'] = True
                        resultado['estado'] = 'SE√ëAL_ENVIADA'
                        self.estadisticas['se√±ales_enviadas_telegram'] += 1
                        
                        logger.info(f"üì§ {simbolo} - Se√±al enviada a Telegram")
                    else:
                        resultado['error'] = procesamiento.get('error', 'Error desconocido')
                        resultado['estado'] = 'ERROR_ENVIO'
                        
                        logger.warning(f"‚ö†Ô∏è  {simbolo} - Error enviando se√±al: {resultado['error']}")
            else:
                resultado['estado'] = 'SIN_SE√ëAL'
                logger.debug(f"‚ÑπÔ∏è  {simbolo} - Sin se√±al en este ciclo")
        
        except Exception as e:
            resultado['estado'] = 'ERROR'
            resultado['error'] = str(e)
            logger.error(f"‚ùå {simbolo} - Error en an√°lisis: {e}")
        
        return resultado
    
    async def obtener_posiciones_activas(self) -> List[Dict]:
        """Obtiene posiciones activas desde Binance"""
        if not self.binance_manager:
            return []
        
        try:
            if hasattr(self.binance_manager, 'get_positions'):
                posiciones = await self.binance_manager.get_positions()
                
                # Filtrar posiciones con tama√±o > 0
                posiciones_activas = [
                    pos for pos in posiciones 
                    if abs(float(pos.get('positionAmt', 0))) > 0
                ]
                
                self.estadisticas['posiciones_activas'] = len(posiciones_activas)
                return posiciones_activas
            
            return []
            
        except Exception as e:
            logger.error(f"‚ùå Error obteniendo posiciones: {e}")
            return []
    
    async def enviar_estado_telegram(self):
        """Env√≠a estado del sistema a Telegram"""
        if not self.telegram_bot:
            return
        
        try:
            # Obtener posiciones activas
            posiciones = await self.obtener_posiciones_activas()
            
            # Construir mensaje
            tiempo_activo = datetime.now() - self.iniciado_en
            horas, remainder = divmod(int(tiempo_activo.total_seconds()), 3600)
            minutos, _ = divmod(remainder, 60)
            
            mensaje = (
                "üìä *ESTADO DEL SISTEMA*\n"
                f"‚Ä¢ Tiempo activo: {horas}h {minutos}m\n"
                f"‚Ä¢ Ciclos completados: {self.estadisticas['ciclos_completados']}\n"
                f"‚Ä¢ Se√±ales generadas: {self.estadisticas['se√±ales_generadas']}\n"
                f"‚Ä¢ Se√±ales enviadas: {self.estadisticas['se√±ales_enviadas_telegram']}\n"
                f"‚Ä¢ Posiciones activas: {len(posiciones)}\n"
                f"‚Ä¢ √öltimo ciclo: {self.estadisticas['ultimo_ciclo'] or 'N/A'}\n"
                f"‚Ä¢ Estado actual: {self.estado}"
            )
            
            # A√±adir detalles de cerebros
            mensaje += "\n\nüß† *ESTADO CEREBROS:*\n"
            for simbolo, cerebro in self.cerebros.items():
                estado_cerebro = cerebro.get_estado()
                mensaje += f"‚Ä¢ {simbolo}: {estado_cerebro['estado']}\n"
            
            # A√±adir posiciones activas si las hay
            if posiciones:
                mensaje += "\nüíº *POSICIONES ACTIVAS:*\n"
                for pos in posiciones:
                    simbolo = pos.get('symbol', '')
                    cantidad = float(pos.get('positionAmt', 0))
                    pnl = float(pos.get('unRealizedProfit', 0))
                    
                    if cantidad != 0:
                        direccion = "LONG" if cantidad > 0 else "SHORT"
                        mensaje += f"‚Ä¢ {simbolo} {direccion}: {abs(cantidad):.4f} (PNL: {pnl:.2f} USDT)\n"
            
            await self.telegram_bot.enviar_mensaje(mensaje)
            logger.info("üìä Estado del sistema enviado a Telegram")
            
        except Exception as e:
            logger.error(f"‚ùå Error enviando estado a Telegram: {e}")
    
    async def ejecutar_ciclo_continuo(self):
        """Ejecuta ciclos de an√°lisis de forma continua"""
        self.ciclo_activo = True
        self.estado = "EJECUTANDO"
        
        logger.info("üîÑ Iniciando ciclo continuo de an√°lisis")
        
        if self.telegram_bot:
            await self.telegram_bot.enviar_mensaje(
                "üîÑ *INICIANDO CICLO CONTINUO DE AN√ÅLISIS*"
            )
        
        ciclo_numero = 0
        while self.ciclo_activo:
            try:
                ciclo_numero += 1
                logger.info(f"üîÑ Ciclo #{ciclo_numero} iniciado")
                
                # Ejecutar ciclo de an√°lisis
                resultados = await self.ciclo_analisis()
                
                # Enviar estado cada 10 ciclos o cada 10 minutos
                if ciclo_numero % 10 == 0:
                    await self.enviar_estado_telegram()
                
                # Verificar stop loss diario
                if await self.verificar_stop_loss_diario():
                    logger.warning("‚õî Stop loss diario alcanzado, deteniendo sistema")
                    await self.detener()
                    break
                
                # Esperar para siguiente ciclo
                logger.info(f"‚è≥ Esperando {self.intervalo_analisis}s para pr√≥ximo ciclo...")
                await asyncio.sleep(self.intervalo_analisis)
                
                # Verificar si se alcanz√≥ el m√°ximo de ciclos
                if self.max_ciclos and ciclo_numero >= self.max_ciclos:
                    logger.info(f"‚úÖ M√°ximo de {self.max_ciclos} ciclos alcanzado")
                    await self.detener()
                    break
                    
            except asyncio.CancelledError:
                logger.info("Ciclo cancelado por usuario")
                break
                
            except Exception as e:
                logger.error(f"‚ùå Error en ciclo continuo: {e}")
                self.estadisticas['errores'] += 1
                
                # Esperar antes de reintentar
                await asyncio.sleep(30)
    
    async def verificar_stop_loss_diario(self) -> bool:
        """Verifica si se alcanz√≥ el stop loss diario"""
        try:
            if not self.binance_manager:
                return False
            
            # Obtener P&L del d√≠a
            if hasattr(self.binance_manager, 'get_daily_pnl'):
                daily_pnl = await self.binance_manager.get_daily_pnl()
                stop_loss_diario = self.config['sistema']['stop_loss_diario']
                
                if daily_pnl < 0 and abs(daily_pnl) >= stop_loss_diario:
                    logger.error(f"‚õî Stop loss diario alcanzado: {daily_pnl:.2f} USDT")
                    
                    if self.telegram_bot:
                        mensaje = (
                            f"‚õî *STOP LOSS DIARIO ALCANZADO*\n"
                            f"‚Ä¢ P√©rdida hoy: {daily_pnl:.2f} USDT\n"
                            f"‚Ä¢ L√≠mite: {stop_loss_diario} USDT\n"
                            f"‚Ä¢ Sistema detenido autom√°ticamente"
                        )
                        await self.telegram_bot.enviar_mensaje(mensaje)
                    
                    return True
            
            return False
            
        except Exception as e:
            logger.error(f"‚ùå Error verificando stop loss diario: {e}")
            return False
    
    async def iniciar(self):
        """Inicia el sistema completo"""
        try:
            logger.info("üöÄ Iniciando Sistema Principal Futures...")
            self.estado = "INICIANDO"
            
            # 1. Inicializar Binance
            logger.info("1Ô∏è‚É£ Inicializando Binance Futures...")
            binance_ok = await self.inicializar_binance()
            
            if not binance_ok:
                logger.warning("‚ö†Ô∏è  Binance no inicializado correctamente, continuando en modo simulaci√≥n")
            
            # 2. Inicializar Telegram
            logger.info("2Ô∏è‚É£ Inicializando Telegram...")
            telegram_ok = await self.inicializar_telegram()
            
            if not telegram_ok:
                logger.warning("‚ö†Ô∏è  Telegram no inicializado, continuando sin notificaciones")
            
            # 3. Inicializar cerebros
            logger.info("3Ô∏è‚É£ Inicializando cerebros...")
            cerebros_ok = await self.inicializar_cerebros()
            
            if not cerebros_ok:
                logger.error("‚ùå No se pudieron inicializar cerebros, abortando")
                return False
            
            # 4. Configurar intervalo de an√°lisis
            self.intervalo_analisis = self.config['sistema']['intervalo_analisis']
            
            # 5. Iniciar ciclo continuo
            logger.info("‚úÖ Sistema inicializado correctamente")
            self.estado = "LISTO"
            
            if self.telegram_bot:
                await self.telegram_bot.enviar_mensaje(
                    "‚úÖ *SISTEMA INICIALIZADO CORRECTAMENTE*\n"
                    "Ciclo continuo de an√°lisis iniciado"
                )
            
            # Ejecutar en segundo plano
            asyncio.create_task(self.ejecutar_ciclo_continuo())
            
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Error iniciando sistema: {e}")
            self.estado = "ERROR"
            return False
    
    async def detener(self):
        """Detiene el sistema de forma controlada"""
        logger.info("üõë Deteniendo Sistema Principal Futures...")
        self.ciclo_activo = False
        self.estado = "DETENIENDO"
        
        # Enviar mensaje final a Telegram
        if self.telegram_bot:
            tiempo_activo = datetime.now() - self.iniciado_en
            horas, remainder = divmod(int(tiempo_activo.total_seconds()), 3600)
            minutos, _ = divmod(remainder, 60)
            
            resumen = (
                f"üõë *SISTEMA DETENIDO*\n"
                f"‚Ä¢ Tiempo activo: {horas}h {minutos}m\n"
                f"‚Ä¢ Ciclos completados: {self.estadisticas['ciclos_completados']}\n"
                f"‚Ä¢ Se√±ales generadas: {self.estadisticas['se√±ales_generadas']}\n"
                f"‚Ä¢ Errores: {self.estadisticas['errores']}\n"
                f"‚Ä¢ Gracias por usar el sistema!"
            )
            
            await self.telegram_bot.enviar_mensaje(resumen)
        
        self.estado = "DETENIDO"
        logger.info("‚úÖ Sistema detenido correctamente")
    
    class SimuladorBinance:
        """Simulador de Binance para desarrollo y pruebas"""
        
        def __init__(self):
            self.balance = 10000.0
            self.positions = {}
            logger.info("ü§ñ Simulador Binance inicializado (modo prueba)")
        
        async def get_balance(self) -> float:
            """Devuelve balance simulado"""
            return self.balance
        
        async def set_leverage(self, leverage: int):
            """Configura leverage (simulado)"""
            logger.debug(f"ü§ñ Simulador: Leverage configurado a {leverage}X")
        
        async def set_margin_type(self, margin_type: str):
            """Configura tipo de margen (simulado)"""
            logger.debug(f"ü§ñ Simulador: Margen configurado a {margin_type}")
        
        def get_symbol_price(self, symbol: str) -> float:
            """Devuelve precio simulado"""
            # Precios base aproximados
            precios_base = {
                'BTCUSDT': 62500.0,
                'ETHUSDT': 3450.0,
                'SOLUSDT': 145.0,
                'LINKUSDT': 18.5,
                'BNBUSDT': 580.0
            }
            
            precio = precios_base.get(symbol, 100.0)
            # A√±adir algo de variaci√≥n aleatoria
            import random
            variacion = random.uniform(-0.005, 0.005)
            return precio * (1 + variacion)
        
        async def get_positions(self) -> List[Dict]:
            """Devuelve posiciones simuladas"""
            return []

# Punto de entrada principal
async def main():
    """Funci√≥n principal para ejecutar el sistema"""
    print("=" * 60)
    print("üöÄ SISTEMA PRINCIPAL DE TRADING FUTURES")
    print("=" * 60)
    
    # Crear instancia del sistema
    sistema = SistemaPrincipalFutures()
    
    try:
        # Iniciar sistema
        inicio_exitoso = await sistema.iniciar()
        
        if not inicio_exitoso:
            print("‚ùå Error iniciando el sistema")
            return
        
        print("‚úÖ Sistema iniciado correctamente")
        print("üìä Presiona Ctrl+C para detener")
        
        # Mantener el programa corriendo
        while sistema.estado == "EJECUTANDO":
            await asyncio.sleep(1)
            
    except KeyboardInterrupt:
        print("\nüõë Detenci√≥n solicitada por usuario")
        await sistema.detener()
        
    except Exception as e:
        print(f"‚ùå Error cr√≠tico: {e}")
        await sistema.detener()
    
    print("üëã Programa terminado")

if __name__ == "__main__":
    # Ejecutar sistema
    asyncio.run(main())
